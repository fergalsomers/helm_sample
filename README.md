# helm_sample  <!-- omit from toc -->
Simple example for deployment parameterization via Helm.

See the [values.yaml](/simpleapp/values.yaml) chart for environment values in the `env:` section.
Helm uses these values when rendering the [deployment.yaml template](/simpleapp/templates/deployment.yaml)

- [Prerequisites](#prerequisites)
- [Steps](#steps)
  - [View the generated template](#view-the-generated-template)
  - [Create a kind cluster](#create-a-kind-cluster)
  - [Create the manual secret](#create-the-manual-secret)
  - [Deploy the Helm simpleapp](#deploy-the-helm-simpleapp)
  - [Have a look at the logs](#have-a-look-at-the-logs)
  - [Clean-up](#clean-up)
- [Notes](#notes)
  - [Things to potentially learn from](#things-to-potentially-learn-from)
  - [Secrets](#secrets)


# Prerequisites

1. Helm installed
2. Kubectl installed
3. Kind installed
4. Make installed


# Steps

## View the generated template

You can use the `helm template` command to view environment variable bindings for the `simpleapp` [deployment](/simpleapp/templates/deployment.yaml)
by running the following command

```bash
helm template simpleapp | grep "env:" -A 16
```

It should print something like this:

```
          env:
            - name: A
              value: "1"
            - name: B
              valueFrom:
                configMapKeyRef:
                  key: X-KEY
                  name: simpleapp-config
            - name: C
              valueFrom:
                secretKeyRef:
                  key: Y-KEY
                  name: simpleapp-secret
            - name: D
              valueFrom:
                secretKeyRef:
                  key: Z-KEY
```

This env stanza defines 4 environment variables:

1. `A` - defined directly, 
2. `B` taken using the `X-Key` from the [simpleapp-configmap.yaml](/simpleapp/templates/simpleapp-configmap.yaml) configmap template 
3. `C` taken using the `Y-Key` from the [simpleapp-secret.yaml](/simpleapp/templates/simpleapp-secret.yaml) secret template
4. `D` taken using the `Z-Key` from the manually created secret `another-secret`

## Create a kind cluster

```bash
make kind
```

Should print something like this
```
kind create cluster --name=kind
Creating cluster "kind" ...
 ✓ Ensuring node image (kindest/node:v1.30.0) 🖼
 ✓ Preparing nodes 📦
 ✓ Writing configuration 📜
 ✓ Starting control-plane 🕹️
 ✓ Installing CNI 🔌
 ✓ Installing StorageClass 💾
Set kubectl context to "kind-kind"
You can now use your cluster with:

kubectl cluster-info --context kind-kind

```

## Create the manual secret

Execute the following commmand to create a new secret in the `default` namespace which will ultimately be bound to the `D` environment variable 

```bash
make secret
```

##  Deploy the Helm simpleapp

```
make helm-deploy
```

This will deploy the Helm applicattion using the following helm command:

```
helm upgrade --install simpleapp ./simpleapp  --set image.tag=latest --set secret=3
```
note we are setting a Helm override for the secret to be 3 - this will be the value of the Y-Key in the generated secret

## Have a look at the logs

``` 
make logs
```

Should eventually print:

```
Hello world
Here are some ENV variables : A = 1, B = 2, C = 3, D = 4
```

So each of the environment variables has been bound correctly. 

## Clean-up

To clean up run the following command it will delete everything including the kind cluster.

```
make clean
```

# Notes


## Things to potentially learn from

- The [Makefile](/Makefile) contains the commands above. Spend some time learning how these commands were created. 
- The [values.yaml](/simpleapp/values.yaml) contains the environment stanza dn the volume mounts for the startup script that prints the log message. 
- The [deployment.yaml](/simpleapp/templates/deployment.yaml) - this was largely generated by `helm create` command with a few modifications for command and env.


## Secrets 

The example creates 2 secrets: 

- One secret is defined in a template [simpleapp-secret.yaml](/simpleapp/templates/simpleapp-secret.yaml), but it's value is bound at helm deploy time
  via a helm override `--set secret=3` see [Makefile](/Makefile) for more details. 
- The other secret `another-secret` is created manually in [create the manual secret step](#create-the-manual-secret) above. 

Both mechanisms work, so which should you use. Putting secrets into Helm Charts, even with late binding at helm-deploy time is not a great practice. 
Even though Helm stores it's internal information in Kubernetes secrets they are visible to anyone who has helm access e.g.

```bash
> helm get values simpleapp
USER-SUPPLIED VALUES:
image:
  tag: latest
secret: 3
```

As you can see the value is visible via Helm. Often many developers have access to helm and so this is not a great level of security. 

Generally, kubernetes secret provisioning should be done out of band from deployment. 

1. Store your secrets in a secrets backend such as
[Amazon Secrets Manager](https://docs.aws.amazon.com/secretsmanager/latest/userguide/intro.html) or [Vault](https://www.vaultproject.io/)
2. Provision your secrets using an operator such as [External Secrets Operator](https://external-secrets.io/latest/) or access secrets directly in your pods by binding [Secrets Store CSI Driver](https://secrets-store-csi-driver.sigs.k8s.io/)

